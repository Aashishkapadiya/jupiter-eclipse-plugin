snippet 1:

//    // 2nd try. If there exists no target file, then search the fully qualified class name 
//    // to open the corresponding editor.
//    if (!className.equals("") && isClassAvailable(className, new IJavaElement[] {javaProject})) {
//      ITextEditor textEditor;
//      try {
//        page.bringToTop(pilotEditorPart);       
//        textEditor = (ITextEditor) JavaUI.openInEditor(javaElement);
//        try {
//          IEditorInput editorInput = textEditor.getEditorInput();
//          IDocument document = textEditor.getDocumentProvider().getDocument(editorInput);
//          textEditor.selectAndReveal(document.getLineOffset(lineNumber),
//                                     document.getLineLength(lineNumber));
//        }
//        catch (BadLocationException e) {
//          // if the line number is invalid in this document.
//          log.debug(e.getMessage());
//        }
//      }
//      catch (PartInitException e) {
//        // if the editor could not be initialized.
//        log.debug(e.getMessage());
//      }
//      catch (JavaModelException e) {
//        // if this element does not exist or if an exception occurs while accessing its
//        // underlying resource.
//        log.debug(e.getMessage());
//      }
//    }


snippet 2:

  /**
   * Checks if the target fully qualified class is available (exists). Returns
   * <code>true</code> if available. Otherwise return <code>false</code>.
   * @param fullyQualifiedClass the fully qualified class name.
   * @param javaElements the target scope. For example, clients can specify the IJavaProject as one
   * of the elements.
   * @return <code>true</code> if available. Otherwise return <code>false</code>
   */
  public static boolean isClassAvailable(String fullyQualifiedClass, IJavaElement[] javaElements) {
    // if empty string, no need to check class availability
    if (fullyQualifiedClass.equals("")) {
      return false;
    }
    ISearchPattern pattern = SearchEngine.createSearchPattern(fullyQualifiedClass, 
                                                              IJavaSearchConstants.TYPE,
                                                              IJavaSearchConstants.DECLARATIONS,
                                                              true);
  
    IJavaSearchScope scope = SearchEngine.createJavaSearchScope(javaElements);
    javaElement = null;
    IJavaSearchResultCollector collector = new IJavaSearchResultCollector() {
        public void aboutToStart() {
        }
        /**
         * Accepts if the resource is found.
         */
        public void accept(IResource resource, int start, int end, IJavaElement enclosingElement,
          int accuracy) {
            javaElement = enclosingElement;
        }
        public void done() {
        }
        public IProgressMonitor getProgressMonitor() {
          return null;
        }
      };
  
    SearchEngine searchEngine = new SearchEngine();
    try {
      searchEngine.search(ResourcesPlugin.getWorkspace(), pattern, scope, collector);
    }
    catch (JavaModelException e) {
      // if the search failed. Reasons include: 
      // - the classpath is incorrectly set
      log.debug(e.getMessage());
    }
    return (javaElement != null);
  }